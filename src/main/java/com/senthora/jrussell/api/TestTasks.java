package com.senthora.jrussell.api;

import com.senthora.jrussell.internal.TestTaskBuilderImpl;

import java.util.Objects;
import java.util.concurrent.Callable;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Entry point for defining test tasks.
 * <p>
 * This class is used to select a task identity and
 * create task builders without executing any task logic.
 * <h3>API Guarantees</h3>
 * <ul>
 *     <li>No task logic is executed by any method in this class.</li>
 *     <li>All builders created through this API are associated with a task identifier.</li>
 *     <li>Each call to create a task builder returns a new builder instance.</li>
 * </ul>
 * <h3>Design Notes</h3>
 * <ul>
 *     <li>Task identity is selected before executable logic.
 *     Callers cannot accidentally define a task without an identity.</li>
 *     <li>This class does not create tasks; it creates identity selectors and builders.
 *     This prevents identity from being influenced by decoration or execution concerns</li>
 *     <li>The API performs no normalization, validation, or collision prevention.
 *     Responsibility for identifier uniqueness is explicitly on the caller.</li>
 *     <li>Each builder creation is explicit and isolated. Each builder creation is
 *     explicit and isolated. Every call produces a fresh task-definition context.</li>
 * </ul>
 *
 * @apiNote
 * There are intentionally no shortcuts around identity selection.
 * There is no “quick task” or “anonymous task” constructor.
 * Even unnamed tasks are still explicitly identified.
 */
public final class TestTasks {

    private TestTasks() {}

    /**
     * Creates an {@link IdentitySelector} with
     * the provided task identifier.
     *
     * @apiNote
     * Callers are responsible for ensuring that the
     * provided identifier does not unintentionally
     * collide with identifiers used elsewhere.
     *
     * @param id task identifier to associate with subsequently built tasks
     * @return a new task identity selector
     *
     * @throws NullPointerException if {@code id} is {@code null}
     * @throws IllegalStateException if {@code id} is an empty String
     */
    public static IdentitySelector named(String id) {
        Objects.requireNonNull(id, "id must not be null");
        if (id.isEmpty()) {
            throw new IllegalArgumentException("Task identity must not be an empty String");
        }
        return new IdentitySelector(id);
    }

    /**
     * Creates an {@link IdentitySelector} with
     * an automatically generated task identifier.
     *
     * @apiNote
     * The generated identifier is guaranteed to be unique
     * only among identifiers generated by this method.
     * Callers should not assume it cannot collide with
     * identifiers provided via {@link #named(String)}.
     *
     * @return a new task identity selector
     */
    public static IdentitySelector unnamed() {
        return new IdentitySelector();
    }

    /**
     * Represents a chosen task identity from which
     * one or more task definitions can be created.
     * <p>
     * It acts as a factory for task builders that share the
     * same identity, binding stable task identifiers before
     * any executable logic or execution behavior is defined.
     * <h3>API Guarantees</h3>
     * <ul>
     *     <li>Each instance represents exactly one task identifier.</li>
     *     <li>All builders created from the same selector are associated with that identifier.</li>
     *     <li>Each call to create a builder returns a new builder instance.</li>
     * </ul>
     * <h3>Operational Notes</h3>
     * <ul>
     *     <li>Auto-generated identifiers are not globally unique.
     *     Uniqueness is guaranteed only among identifiers generated
     *     by this API, not across JVM runs or external systems.</li>
     *     <li>The identifier is fixed for the lifetime of the selector
     *     and all builders created from it. Builders created from the
     *     same selector intentionally share the same task identity.</li>
     * </ul>
     * <h3>Usage Guidelines</h3>
     * <ul>
     *     <li>Reuse an {@code IdentitySelector} only when multiple tasks
     *     are intended to share the same logical task identity.</li>
     * </ul>
     *
     * @implNote
     * This class wires public task definitions to internal
     * builders to centralize decorator composition and
     * enforce immutability after build.
     */
    @UsesInternal
    public static final class IdentitySelector {

        private static final AtomicLong SEQ = new AtomicLong();

        private final String id;

        private IdentitySelector(String id) {
            this.id = Objects.requireNonNull(id, "task id must not be null");
        }

        private IdentitySelector() {
            this.id = "test-task-" + SEQ.incrementAndGet();
        }

        /**
         * Creates a new task builder using the provided executable.
         *
         * @apiNote
         * Intended for tasks that produce a result value.
         *
         * @param task executable logic for the task
         * @param <T> result type produced by the task
         * @return a new task builder associated with this selector's identity
         *
         * @see #runnable(Runnable)
         */
        public <T> TestTaskBuilder<T> callable(Callable<T> task) {
            return new TestTaskBuilderImpl<>(id, task);
        }

        /**
         * Creates a new task builder using the provided runnable.
         *
         * @apiNote
         * Intended for tasks that do not produce a result value.
         *
         * @param runnable executable logic for the task
         * @return a new task builder associated with this selector's identity
         *
         * @see #callable(Callable)
         */
        public TestTaskBuilder<Void> runnable(Runnable runnable) {
            return new TestTaskBuilderImpl<>(id, () -> {
                runnable.run();
                //noinspection DataFlowIssue
                return null;
            });
        }
    }
}
